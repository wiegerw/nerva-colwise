= Nerva-colwise C++ manual
:copyright: Copyright 2024 Wieger Wesselink
:author: Wieger Wesselink
:email: j.w.wesselink@tue.nl
:doctype: book
:toc: left
:toc2:
:toc-title: pass:[<h3>Contents</h3>]
:css-signature: demo
:stem: latexmath
:icons: font
:description: Documentation for the nerva-colwise repository.
:library: pass:q[_Nerva-Colwise C++ Library_]
:imagesdir: images
:bibliography: nerva.bib
:mlptool: mlp
:sgd_algorithm: stochastic_gradient_descent_algorithm

ifdef::env-github[]
:note-caption: :information_source:
endif::[]

++++
<style>
  .small-code .content pre {
      font-size: 0.7em;
  }
</style>
++++

== Introduction
This document describes the implementation of the {library}. In earlier versions, I relied heavily on lecture notes from https://www.cs.toronto.edu/~rgrosse/teaching.html[machine learning courses by Roger Grosse], which I highly recommend. This influence may still be evident in the naming of symbols.

=== Difference with the Nerva-Rowwise C++ library
The {library} can be viewed as the dual of the https://github.com/wiegerw/nerva-rowwise[Nerva-Rowwise {cpp} Library]. The main difference between the two is that the {library} assumes that examples of a dataset are stored in the columns of a matrix, while the Nerva-Rowwise C++ Library assumes that the examples are stored in the rows of a matrix. The work on the Nerva libraries started with the column-wise version. From a mathematical point of view this makes sense, since if the input stem:[x] is a column vector, the equation of a linear layer can be written as stem:[y = W x + b], which is common in linear algebra. However, later it turned out that this choice causes subtle problems for the compatibility with existing frameworks like PyTorch, TensorFlow and JAX. Due to this a switch has been made to the row-wise version. In this version, the equation of a linear layer is given by stem:[y = x^\top W + b].

Obviously, the Nerva-Colwise and Nerva-Rowwise libraries share a lot of code. But in particular, the mathematical equations of the layers, softmax functions and loss functions are different.

=== Installation
The following build systems are supported:

- https://cmake.org/[CMake] 3.16+
- https://www.bfgroup.xyz/b2/[B2]

Using CMake, the {library} can be built in a standard way. The only prerequisite is that the Intel OneAPI library must be installed, and two environment variables must be set. The variable `ONEAPI_ROOT` should point to the OneAPI installation directory, and the variable `MKL_DIR` to the MKL installation directory. The dependencies for doctest, Eigen, FMT, Lyra and pybind11 are resolved automatically using `FetchContent` commands.

==== Linux install
The build and install can for example be done like this on a Linux system:

[[cmake-build]]
[source,bash]
----
mkdir build
cd build
cmake .. \
    -DCMAKE_INSTALL_PREFIX=../install \
    -DCMAKE_BUILD_TYPE=RELEASE \
    -DMKL_DIR:PATH=$ONEAPI_ROOT/mkl/latest/lib/cmake/mkl
make -j8
make install
----
TIP: Setting the `MKL_DIR` variable is not necessary if the OneAPI `setvars.sh` script is run beforehand.

NOTE: For the clang and icpx compilers one should know that there is a longstanding issue between MKL and Eigen. See
https://community.intel.com/t5/Intel-oneAPI-Math-Kernel-Library/Using-MKL-2023-0-0-20221201-with-Eigen/m-p/1456044[1456044]
and https://gitlab.com/libeigen/eigen/-/issues/2586[issues/2586] for more details.
To resolve this issue, a hack has been applied in Nerva: by defining the symbol `EIGEN_COLPIVOTINGHOUSEHOLDERQR_LAPACKE_H`,
the inclusion of the offending header file is prevented.

[NOTE]
====
For the B2 build using the icpx compiler, the environment needs to be changed like this in advance. Alternatively, the OneAPI `setvars.sh` script can be called.
[listing]
----
LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ONEAPI_ROOT/latest/lib
PATH=$PATH:/$ONEAPI_ROOT/latest/bin
----
====

==== SYCL install
There is an experimental computation mode for SYCL matrix operations, that can be enabled in the `mlp` tool using the flag `--computation=sycl`. This is only supported on Linux in combination with the Intel `icpx` compiler. It can be enabled using the following build command:
[source]
----
source $ONEAPI_ROOT/setvars.sh
cmake .. \
-DCMAKE_C_COMPILER=$ONEAPI_ROOT/compiler/latest/bin/icx \
-DCMAKE_CXX_COMPILER=$ONEAPI_ROOT/compiler/latest/bin/icpx \
-DCMAKE_INSTALL_PREFIX=../install \
-DCMAKE_BUILD_TYPE=RELEASE \
-DENABLE_SYCL=ON
----

NOTE: The initial tests with SYCL matrix operations on CPU have a rather disappointing performance.

==== Windows Visual Studio install
On Windows, a Visual Studio command line build can be done like this:
[source]
----
cmake .. ^
    -G "NMake Makefiles" ^
    -DCMAKE_INSTALL_PREFIX=..\install ^
    -DCMAKE_BUILD_TYPE=Release ^
    -DMKL_DIR="%ONEAPI_ROOT%\latest\lib\cmake\mkl"
nmake
nmake install
----
The unit tests can be run using the command

[source]
----
ctest -R nerva
----

TIP: The number of threads that are used at runtime by the MKL library can be controlled using the environment variables `MKL_NUM_THREADS` and `OMP_NUM_THREADS`, see also https://www.intel.com/content/www/us/en/docs/onemkl/developer-guide-linux/2024-2/techniques-to-set-the-number-of-threads.html[techniques-to-set-the-number-of-threads.html].

== Command line tools
The following command line tools are available. They can be found in the `tools` directory.

|===
|Tool |Description

|`mlp`
|A tool for training multilayer perceptrons.

|`mkl`
|A tool for benchmarking sparse and dense matrix products using the Intel MKL library.

|`inspect_npz`
|A tool for inspecting the contents of a file in NumPy NPZ format.
|===

=== The tool mlp
The tool `mlp` can be used for training multilayer perceptrons. An example invocation of the `mlp` tool is

[.small-code]
[source,bash]
----
include::../examples/cifar10_sparse.sh[tag=doc]
----
This will train a CIFAR-10 model using an MLP consisting of three layers with activation functions ReLU, ReLU and no activation. Note that first the CIFAR-10 binary version needs to be downloaded from https://www.cs.toronto.edu/~kriz/cifar.html.

The output may look like this:
[[mlp_output]]
[.small-code]
[listing]
----
=== Nerva c++ model ===
Sparse(input_size=3072, output_size=1024, density=0.042382877, optimizer=Nesterov(0.90000), activation=ReLU())
Sparse(input_size=1024, output_size=1024, density=0.06357384, optimizer=Nesterov(0.90000), activation=ReLU())
Dense(input_size=1024, output_size=10, optimizer=Nesterov(0.90000), activation=NoActivation())
loss = SoftmaxCrossEntropyLoss()
scheduler = ConstantScheduler(lr=0.01)
layer densities: 133325/3145728 (4.238%), 66662/1048576 (6.357%), 10240/10240 (100%)

epoch   0 lr: 0.01000000  loss: 2.30284437  train accuracy: 0.07904000  test accuracy: 0.08060000 time: 0.00000000s
epoch   1 lr: 0.01000000  loss: 2.14723837  train accuracy: 0.21136000  test accuracy: 0.21320000 time: 2.74594253s
epoch   2 lr: 0.01000000  loss: 1.91454245  train accuracy: 0.29976000  test accuracy: 0.29940000 time: 2.76982510s
epoch   3 lr: 0.01000000  loss: 1.78019225  train accuracy: 0.35416000  test accuracy: 0.35820000 time: 2.69554319s
epoch   4 lr: 0.01000000  loss: 1.68071066  train accuracy: 0.39838000  test accuracy: 0.40000000 time: 2.68532307s
epoch   5 lr: 0.01000000  loss: 1.59761505  train accuracy: 0.42820000  test accuracy: 0.43060000 time: 3.02131606s
----

// tag::mlptool-options[]
[[mlp_tool]]
==== {mlptool} command line options
This section gives an overview of the command line interface of the `{mlptool}` tool.

===== Parameters lists

Some command line options take a list of items as input, for example a list of layers. These items must be separated by semicolons, e.g. `--layers="ReLU;ReLU;Linear"`.

===== Named parameters
Some of the items take parameters. For this we use a function call syntax with named parameters, e.g. `AllReLU(alpha=0.3)`. In case that there is only one parameter, the name may be omitted: `AllReLU(0.3)`. If the parameters have default values, they may be omitted. For example, `TReLU` or `TReLU()` is equivalent to `TReLU(al=0,tl=0,ar=0,tr=1)`.
// end::mlptool-options[]

// tag::general-options[]
===== General options
* `-?`, `-h`, `--help`
Display help information.
* `--debug`, `-d`
Show debug output. This prints batches, weight matrices, bias vectors, gradients etc.
// end::general-options[]
* `--verbose`, `-v`
Show verbose output.

// tag::random-generator-options[]
===== Random generator options
* `--seed <value>`
A seed value for the random generator.
// end::random-generator-options[]

// tag::layer-configuration-options[]
===== Layer configuration options
* `--layers <value>`
A semicolon separated list of layers. For example, `--layers=ReLU;AllReLU(0.3);Linear` is used to specify a neural network with three layers with an ReLU, AllReLU and no activation function. The following layers are supported:

|===
|Specification |Description

|`Linear`
|Linear layer without activation

|`ReLU`
|Linear layer with ReLU activation

|`Sigmoid`
|Linear layer with sigmoid activation

|`Softmax`
|Linear layer with softmax activation

|`LogSoftmax`
|Linear layer with log-softmax activation

|`HyperbolicTangent`
|Linear layer with hyperbolic tangent activation

|`AllReLU(<alpha>)`
|Linear layer with All ReLU activation

|`SReLU(<al>,<tl>,<ar>,<tr>)`
|Linear layer with SReLU activation. The default value for the parameters are `al=0, tl=0, ar=0, tr=1`. For these
 values `SReLU` coincides with `ReLU`.

|`TReLU(<epsilon>)`
|Linear layer with trimmed ReLU activation

|`BatchNormalization`
|Batch normalization layer
|===

* `--layer-sizes <value>`
A semicolon-separated list of the sizes of linear layers of the multilayer perceptron. For example, `--layer-sizes=3072;1024;512;10` specifies the sizes of three linear layers. The first one has 3072 inputs and 1024 outputs, the second one 1024 inputs and 512 outputs, and the third one has 512 inputs and 10 outputs.
* `--densities <value>`
A comma-separated list of linear layer densities. By default, all linear layers are dense (i.e. have density 1.0). If only one value is
 specified, it will be used for all linear layers.
* `--dropouts <value>`
A comma-separated list of dropout rates of linear layers. By default, all linear layers have no dropout (i.e. dropout rate 0.0).
* `--overall-density <value>`
The overall density of the linear layers. This value should be in the interval stem:[[0,1]], and it specifies the fraction of the total number of weights that is non-zero. The overall density is not distributed evenly over the layers. Instead, small layers will be assigned a higher density than large layers.
* `--layer-weights <value>`
The generator that is used for initializing the weights of the linear layers. The following weight generators are supported:
|===
|Specification |Description

|`Xavier`
|Xavier weights

|`XavierNormalized`
|Normalized Xavier weights

|`He`
|Kaiming He weights

|`Uniform`
|Uniform weights

|`Zero`
|All weights are zero (N.B. This usually doesn't work)
|===
// end::layer-configuration-options[]

// tag::training-configuration-options[]
===== Training configuration options
* `--epochs <value>`
The number of epochs of the training (default: 100).
* `--batch-size <value>`
The batch size of the training.
* `--no-shuffle`
Do not shuffle the dataset during training.
* `--no-statistics`
Do not display intermediate statistics during training.
* `--optimizers <value>`
A semicolon-separated list of optimizers used for linear and batch normalization layers. The following optimizers are supported:
|===
|Specification |Description

|`GradientDescent`
|Gradient descent optimization

|`Momentum(mu)`
|Momentum optimization with momentum parameter `mu`

|`Nesterov(mu)`
|Nesterov optimization with momentum parameter `mu`
|===

* `--learning-rate <value>`
A semicolon-separated list of learning rate schedulers of linear and batch normalization layers. If only one learning rate scheduler is specified, it is applied to all layers. The following learning rate schedulers are supported:
|===
|Specification |Description

|`Constant(lr)`
|Constant learning rate `lr`

|`TimeBased(lr, decay)`
|Adaptive learning rate with decay

|`StepBased(lr, drop_rate, change_rate)`
|Step based learning rate where the learning rate is regularly dropped
to a lower value

|`MultistepLR(lr, milestones, gamma)`
|Step based learning rate, where `milestones` contains the epoch numbers in which the learning rate is dropped.

|`Exponential(lr, change_rate)`
|Exponentially decreasing learning rate
|===
See also https://en.wikipedia.org/wiki/Learning_rate.

* `--loss <value>`
The loss function used for training the multilayer perceptron. The following loss functions are supported:
|===
|Specification |Description

|`SquaredError`
|Squared error loss.

|`CrossEntropy`
|Cross entropy loss (N.B. prone to numerical problems!)

|`LogisticCrossEntropy`
|Logistic cross entropy loss.

|`SoftmaxCrossEntropy`
|Softmax cross entropy loss. Matches `CrossEntropy` of PyTorch. Suitable for classification experiments.

|`NegativeLogLikelihood`
|Negative log likelihood loss.
|===

* `--load-weights <value>`
Load weights and biases from a dictionary in NumPy `.npz` format.
The weight matrices should be stored with keys `W1,W2,...` and the bias vectors with keys `b1,b2,...`.
See also
link:https://numpy.org/doc/stable/reference/generated/numpy.lib.format.html[numpy.lib.format].

* `--save-weights <value>`
Save weights and biases to a dictionary in NumPy `.npz` format.
The weight matrices are stored with keys `W1,W2,...` and the bias vectors with keys `b1,b2,...`.
See also
link:https://numpy.org/doc/stable/reference/generated/numpy.lib.format.html[numpy.lib.format].
// end::training-configuration-options[]

// tag::dataset-options[]
===== Dataset options
* `--cifar10 <directory>`
Specify the directory where the binary version of the
link:https://www.cs.toronto.edu/~kriz/cifar.html[CIFAR-10] dataset is stored. This is a directory with subdirectory `cifar-10-batches-bin` for the C++ version or `cifar-10-batches-py` for the Python version of the dataset.
* `--mnist <directory>`
Specify the directory where the https://en.wikipedia.org/wiki/MNIST_database[MNIST] dataset is stored.
It should be stored in a file named `mnist.npz`, that can be downloaded https://s3.amazonaws.com/img-datasets/mnist.npz[here].

* `--load-data <value>`
Load the dataset from a file in NumPy `.npz` format. See
* `--save-data <value>`
Save the dataset to a file in NumPy `.npz` format. See

* `--normalize`
Normalize the dataset.
* `--preprocessed <directory>`
A directory containing datasets named `epoch0.npz`, `epoch1.npz`, ... See <<io>> for information about the `.npz` format. This can for example be used to precompute augmented datasets. A script link:../python/tools/generate_cifar10_augmented_datasets.py[generate_cifar10_augmented_datasets.py] is available for creating augmented CIFAR-10 datasets.
// end::dataset-options[]

* `--generate-data <name>`
Specify a synthetic dataset that is generated on the fly. The following datasets are supported:
|===
|Specification |Description |Features |Classes

|`checkerboard`
|A checkerboard pattern, see also link:https://kaifishr.github.io/2021/01/14/micro-mlp.html#checkerboard[checkerboard].
|2
|2

|`mini`
|A dataset with random values.
|3
|2
|===

* `--dataset-size <value>`
The size of the generated dataset (default: 1000).
`--save-weights` for information about the format.
`--load-weights` for information about the format.

// tag::miscellaneous-options[]
===== Miscellaneous options
* `--info`
Print detailed information about the multilayer perceptron.
* `--timer`
Print timer messages. The following values are supported:
|===
|Value |Description

|`disabled`
| No timing information is displayed

|`brief`
| At the end, a report with accumulated timing measurements will be displayed

|`full`
| In addition, individual timing measurements will be displayed
|===

* `--precision <value>`
The precision used for printing matrix elements.
* `--edgeitems <value>`
The edgeitems used for printing matrices. This sets the number of border rows and columns that are printed.
// end::miscellaneous-options[]

// tag::pruning-options[]
===== Pruning and growing options
* `--prune <strategy>`
The strategy used for pruning sparse weight matrices. The following strategies are supported:
|===
|Specification |Description

|`Magnitude(<drop_fraction>)`
|Magnitude based pruning. A fraction of the weights with the smallest absolute value is pruned.

|`SET(<drop_fraction>)`
|SET pruning. Positive and negative weights are treated separately. Both a fraction of the positive and a fraction of the negative weights is pruned.

|`Threshold(<threshold>)`
|Weights with absolute value below the given threshold are pruned.
|===

* `--grow <strategy>`
The strategy used for growing in sparse weight matrices. The following strategies are supported:
|===
|Specification |Description

|`Random`
|Weights are added at random positions (outside the support of the sparse matrix).
|===

* `--grow-weights <value>`
The weight generation function used for growing weights.
See `--layer-weights` for supported values. The default value is `Xavier`.
// end::pruning-options[]

// tag::computation-options[]
===== Computation options
* `--computation <value>`
The computation mode that is used for backpropagation. This is used for performance measurements. The following computation modes are available:
|===
|Specification |Description

|`eigen`
|All computations are done using the Eigen library. Note that by setting the flag `EIGEN_USE_MKL_ALL` Eigen will attempt to use MKL library calls.

|`mkl`
|Some computations are implemented using MKL functions.

|`blas`
|Some computations are implemented using BLAS functions.

|`sycl`
|Some computations are implemented using SYCL functions.
|===

* `--clip <value>`
A threshold value used to set small elements of weight matrices to zero.
* `--threads <value>`
The number of threads used by the MKL and OMP libraries.
* `--gradient-step <value>`
If this value is set, gradient checks are performed with the given step size. This is very slow, and should only be used for debugging.
// end::computation-options[]

=== The tool mkl
The tool `mkl` is used for benchmarking sparse and dense matrix products. An example of running the `mkl` tool is
[.small-code]
[source,bash]
----
include::../examples/mkl_benchmark.sh[tag=doc]
----
This will use various algorithms to calculate the product `A = B * C` with `A` a sparse matrix and `B` and `C` dense matrices.

The output may look like this
[.small-code]
[listing]
----
--- testing A = B * C (sdd_product) ---
A = 1000x1000 sparse
B = 1000x1000 dense  layout=column-major
C = 1000x1000 dense  layout=column-major

density(A) = 0.5
 0.01147s ddd_product A=column-major, B=column-major, C=column-major
 0.00793s ddd_product A=column-major, B=column-major, C=column-major
 0.00854s ddd_product A=column-major, B=column-major, C=column-major
 0.04049s sdd_product(batchsize=5, density(A)=0.499599, B=column-major, C=column-major)
 0.01998s sdd_product(batchsize=5, density(A)=0.499599, B=column-major, C=column-major)
 0.01178s sdd_product(batchsize=5, density(A)=0.499599, B=column-major, C=column-major)
 0.01114s sdd_product(batchsize=10, density(A)=0.499599, B=column-major, C=column-major)
 0.01099s sdd_product(batchsize=10, density(A)=0.499599, B=column-major, C=column-major)
 0.00666s sdd_product(batchsize=10, density(A)=0.499599, B=column-major, C=column-major)
 0.00375s sdd_product(batchsize=100, density(A)=0.499599, B=column-major, C=column-major)
 0.00734s sdd_product(batchsize=100, density(A)=0.499599, B=column-major, C=column-major)
 0.00332s sdd_product(batchsize=100, density(A)=0.499599, B=column-major, C=column-major)
 0.20097s sdd_product_forloop_eigen(density(A)=0.499599, B=column-major, C=column-major)
 0.19891s sdd_product_forloop_eigen(density(A)=0.499599, B=column-major, C=column-major)
 0.19893s sdd_product_forloop_eigen(density(A)=0.499599, B=column-major, C=column-major)
 0.23286s sdd_product_forloop_mkl(density(A)=0.499599, B=column-major, C=column-major)
 0.23298s sdd_product_forloop_mkl(density(A)=0.499599, B=column-major, C=column-major)
 0.23281s sdd_product_forloop_mkl(density(A)=0.499599, B=column-major, C=column-major)
----
Note that the very first invocation of an MKL function can be slow.

=== The tool inspect_npz
The tool `inspect_npz` is a simple tool to show the contents of a file in NumPy NPZ format. The tool `mlp` uses this format to load and save datasets, and to load and save weight matrices + bias vectors of linear layers. The output may look like this:
[.small-code]
[listing]
----
W1 (1024x3072) norm = 0.03827324
   [-0.00850412,  0.00766624, -0.00379110,  ..., -0.02755435,  0.00842837,  0.00725122]
   [ 0.03012662, -0.01122476,  0.03765349,  ...,  0.02167689, -0.03734717, -0.01376905]
   [-0.03415587, -0.00498827,  0.00635345,  ..., -0.03036389, -0.01967963,  0.03339641]
   ...,
   [ 0.02993325, -0.00795984,  0.00388659,  ...,  0.01343446, -0.01625269,  0.00398590]
   [ 0.03800971, -0.01185982, -0.00944855,  ...,  0.02083720, -0.00217844,  0.02398606]
   [-0.00879488, -0.01937520, -0.02830209,  ...,  0.03606736, -0.01065827,  0.03293588]
b1= (1024)
   [-0.01735129, -0.01381215,  0.01708755,  ..., -0.01117092, -0.00264273, -0.00976263]
W2 (512x1024) norm = 0.06249978
   [-0.02440289,  0.01362467,  0.03782336,  ...,  0.01342138, -0.01060697, -0.05055390]
   [ 0.06187645, -0.00854158,  0.02849235,  ...,  0.05861567,  0.00708143, -0.06170959]
   [-0.00756755,  0.04718670, -0.02303848,  ...,  0.01513476,  0.00205931,  0.05441900]
   ...,
   [-0.04223771,  0.00852190, -0.00465803,  ...,  0.03600422,  0.00484904, -0.02281546]
   [ 0.03211500, -0.02740303, -0.04652309,  ...,  0.00307061,  0.02427530, -0.02245107]
   [ 0.05210501, -0.00423148, -0.00633851,  ...,  0.02453317,  0.02723335,  0.03589169]
b2= (512)
   [-0.01871627,  0.01150464, -0.01767523,  ..., -0.00220927, -0.01791467, -0.02616516]
W3 (10x512) norm = 0.10718583
   [-0.03256247, -0.09669271, -0.06564181,  ...,  0.00394586, -0.02191557,  0.08828022]
   [-0.09986399, -0.03712691,  0.04332626,  ..., -0.02475236, -0.07359495, -0.09421349]
   [-0.03308030,  0.01280271,  0.09341474,  ..., -0.03470980, -0.03936023,  0.02204999]
   ...,
   [-0.10063093, -0.04294113, -0.04938528,  ...,  0.08151620, -0.00991420,  0.09686699]
   [ 0.04347997, -0.08046009,  0.02828473,  ...,  0.06899156, -0.08314995,  0.07181197]
   [ 0.00575207, -0.06347645, -0.07257712,  ..., -0.00293436, -0.00266003, -0.08468610]
b3= (10)
   [-0.02117447, -0.00115431, -0.03672279,  ..., -0.02902718, -0.02759255,  0.03007624]
----

== Overview of the code
This section gives an overview of the C++ code in the
{library}, and some information that is needed for understanding the code.

=== Number type
The {library} uses a type called `scalar` as its number type. By default, it is defined as a 32-bit float. It is possible to change this by defining the symbol `NERVA_USE_DOUBLE`, in which case 64 bit doubles are used. The corresponding code is
[.small-code]
[source,cpp]
----
include::../include/nerva/neural_networks/settings.h[tag=doc]
----
A more generic approach would be to add a template argument for the number type to most classes and functions. This has been tried in the past, but since it had a negative impact on the readability of the code, it was later removed.

=== Header files
The most important header files in are given in the table below.

|===
|Header file |Description

|`link:https://github.com/wiegerw/nerva-colwise/blob/main/include/nerva/neural_networks/multilayer_perceptron.h[multilayer_perceptron.h]`
|A multilayer perceptron class.

|`link:https://github.com/wiegerw/nerva-colwise/blob/main/include/nerva/neural_networks/layers.h[layers.h]`
|Neural network layers.

|`link:https://github.com/wiegerw/nerva-colwise/blob/main/include/nerva/neural_networks/activation_functions.h[activation_functions.h]`
|Activation functions.

|`link:https://github.com/wiegerw/nerva-colwise/blob/main/include/nerva/neural_networks/loss_functions.h[loss_functions.h]`
|Loss functions.

|`link:https://github.com/wiegerw/nerva-colwise/blob/main/include/nerva/neural_networks/weights.h[weights.h]`
|Weight initialization functions.

|`link:https://github.com/wiegerw/nerva-colwise/blob/main/include/nerva/neural_networks/optimizers.h[optimizers.h]`
|Optimizer functions, for updating neural network parameters using their gradients.

|`link:https://github.com/wiegerw/nerva-colwise/blob/main/include/nerva/neural_networks/learning_rate_schedulers.h[learning_rate_schedulers.h]`
|Learning rate schedulers, for updating the learning rate during training.

|`link:https://github.com/wiegerw/nerva-colwise/blob/main/include/nerva/neural_networks/training.h[training.h]`
|A stochastic gradient descent algorithm.

|`link:https://github.com/wiegerw/nerva-colwise/blob/main/include/nerva/neural_networks/prune.h[prune.h]`
|Algorithms for pruning sparse weight matrices. This is used for dynamic sparse training.

|`link:https://github.com/wiegerw/nerva-colwise/blob/main/include/nerva/neural_networks/grow.h[grow.h]`
|Algorithms for (re-)growing sparse weights. This is used for dynamic sparse training.
|===

=== Classes

==== Class multilayer_perceptron
A multilayer perceptron (MLP) is modeled using the class `multilayer_perceptron`. It contains a list of layers, and has member functions `feedforward`, `backpropagate` and `optimize` that can be used for training the neural network. Constructing an MLP can be done manually, as is illustrated in the tests:
[.small-code]
[source,cpp]
----
include::../tests/multilayer_perceptron_test.cpp[tag=doc]
----
This will create an MLP with three linear layers that have weight matrices `W1, W2, W3` and bias vectors `b1, b2, b3`. The parameter `sizes` contains the input and output sizes of the three layers. Note that the layers and the optimizers are stored using smart pointers. This is done to facilitate the Nerva Python interface. Constructing an MLP like this is quite verbose. An easier way to construct MLPs is provided by the function `make_layers`, that offers a string based interface.

[.small-code]
[source,cpp]
----
include::../tests/gradient_test.cpp[tag=construct_mlp]
----
Note that the random number generator argument is used for the generation of the weights. See
<<mlp_tool, mlp command line options>> for an overview of the supported string arguments.

==== Class neural_network_layer
The class `neural_network_layer` is the base class of all neural network layers. It has attributes for the input matrix `X` and the corresponding gradient `DX`. Usually a layer has some additional parameters that can be learned by training the neural network. The most important member functions of `neural_network_layer` are given below.
[.small-code]
[source,cpp]
----
include::../include/nerva/neural_networks/layers.h[tag=layer]
----

==== Class loss_function
The class `loss_function` is the base class of all loss functions. Although a loss function is similar to a layer, the interface is different:
[.small-code]
[source,cpp]
----
include::../include/nerva/neural_networks/loss_functions.h[tag=doc]
----
So instead of the names `feedforward` and `backpropagate`, we use `value` and `gradient`.

There are five loss functions available:

* `squared_error_loss`

* `cross_entropy_loss`

* `logistic_cross_entropy_loss`

* `softmax_cross_entropy_loss`

* `negative_log_likelihood_loss`

==== Activation functions
Currently, there is no common base class for activation functions. For example, the ReLU activation function is implemented like this:
[.small-code]
[source,cpp]
----
include::../include/nerva/neural_networks/activation_functions.h[tag=doc]
----

NOTE: Currently, there are some inconsistencies between the
interfaces of layers, loss functions and activation functions. This may be changed in the future.

=== Training a neural network
The class `stochastic_gradient_descent_algorithm` can be used to train a neural network. It takes as input a multilayer perceptron, a dataset, a loss function, a learning rate scheduler, and a struct containing options like the number of epochs. The main loop looks like this:
[.small-code]
[source,cpp]
----
for (unsigned int epoch = 0; epoch < options.epochs; ++epoch)
{
  on_start_epoch(epoch);

  eigen::matrix DY(L, options.batch_size);

  for (long batch_index = 0; batch_index < K; batch_index++)
  {
    on_start_batch(batch_index);

    eigen::eigen_slice batch(I.begin() + batch_index * options.batch_size, options.batch_size);
    auto X = data.Xtrain(batch, Eigen::indexing::all);
    auto T = data.Ttrain(batch, Eigen::indexing::all);

    M.feedforward(X, Y);
    DY = loss->gradient(Y, T) / options.batch_size;
    M.backpropagate(Y, DY);
    M.optimize(learning_rate);

    on_end_batch(batch_index);
  }
  on_end_epoch(epoch);
}
----
In every epoch, the dataset is divided into `K` batches. A batch `X` consists of `batch_size` examples, with corresponding targets `T` (i.e. the expected outputs). Each batch goes through the three steps of stochastic gradient descent:

. *feedforward:* Given an input batch `X` and
the neural network parameters `Θ`, compute the
output `Y`.
. *backpropagation:* Given output `Y` corresponding to input `X` and targets `T`, compute the gradient  `DY` of `Y` with respect to the loss function. Then from `Y` and `DY`, compute the gradient `DΘ` of the parameters `Θ`.
. *optimization:* Given the gradient `DΘ`, update
the parameters `Θ`.

// tag::event-functions[]
Note that the algorithm uses a number of event functions:
|===
|Event |Description

|`on_start_training`
|Is called at the start of the training

|`on_end_training`
|Is called at the end of the training

|`on_start_epoch`
|Is called at the start of each epoch

|`on_end_epoch`
|Is called at the end of each epoch

|`on_start_batch`
|Is called at the start of each batch

|`on_end_batch`
|Is called at the end of each batch
|===
The user can respond to these events by deriving from the class `{sgd_algorithm}`. Typical use cases for these event functions are the following:

- Update the learning rate.
- Renew dropout masks.
- Prune and grow sparse weights.

Such operations are typically done after each epoch or after a given number of batches.
// end::event-functions[]

[[on_start_epoch]]
An example can be found in the tool `mlp`:
[.small-code]
[source,cpp]
----
include::../tools/mlp.cpp[tag=event]
----

// tag::event-actions[]
Five actions take place at the start of every epoch:

- A preprocessed dataset is loaded from disk, which is done to avoid the expensive computation of augmented data at every epoch.
- The learning rate is updated if a learning rate scheduler is set.
- Dropout masks are renewed.
- Sparse weight matrices are pruned and regrown if a regrow function is specified.
- Small weights in the subnormal range are clipped to zero if the `clip` option is set.
// end::event-actions[]

=== Timers
The {library} has two timer classes, defined in the header file `link:https://github.com/wiegerw/nerva-colwise/blob/main/include/nerva/utilities/timer.h[timer.h]`:

|===
|class |description

|`map_timer`
|A timer that can be used for timing different operations.
 Each operation is identified using a name, and for each name all timing results are stored.

|`resumable_timer`
|This is a `map_timer` that can be suspended.
|===

The {library} uses a predefined timer `nerva_timer` that is defined in the header file `link:https://github.com/wiegerw/nerva-colwise/blob/main/include/nerva/neural_networks/nerva_timer.h[nerva_timer.h]`.
The `mlp` tool uses this timer to keep track of the time spent on feedforward, backpropagate and optimize calls during training, and optionally of other computations. Each computation is identified with a unique name. If the option `--timer=brief` is set, the accumulated times of all computations will be displayed:
[listing]
----
--- timing results ---
backpropagate        = 5.6162
batchnorm1           = 0.0895
batchnorm2           = 0.0418
batchnorm3           = 0.1030
batchnorm4           = 0.8833
feedforward          = 1.4613
optimize             = 0.1137
total time           = 8.3089
----

For fine-grained measurements two macros `NERVA_TIMER_START` and `NERVA_TIMER_STOP` are defined for starting and stopping the timer. An example can be found in the backpropagate call of batch normalization layers:
[.small-code]
[source,cpp]
----
include::../include/nerva/neural_networks/batch_normalization_layers.h[tag=timer]
----
To avoid any overhead, these macros can be disabled by defining the symbol `NERVA_DISABLE_TIMER`. If the option `--timer=full` is set, all individual timings will be displayed:
[.small-code]
[listing]
----
    feedforward-1    0.001753s
     batchnorm1-1    0.000096s
     batchnorm2-1    0.000043s
     batchnorm3-1    0.000099s
     batchnorm4-1    0.001125s
  backpropagate-1    0.006895s
       optimize-1    0.000184s
    feedforward-2    0.001773s
     batchnorm1-2    0.000117s
     batchnorm2-2    0.000051s
     batchnorm3-2    0.000124s
     batchnorm4-2    0.001280s
  backpropagate-2    0.006300s
       optimize-2    0.000115s
    feedforward-3    0.001471s
     batchnorm1-3    0.000071s
     batchnorm2-3    0.000023s
     batchnorm3-3    0.000088s
     batchnorm4-3    0.000667s
----
The calls are numbered, to make it easy to compare different runs. Unsurprisingly, the timing output shows that the computation labeled `batchnorm4` takes the majority of time.

== Matrix operations
The most important part of the implementation of neural networks consists of matrix operations. In the implementation of activation functions, loss functions and neural network layers, many different matrix operations are needed. In Nerva a structured approach is followed to implement these components. All equations are expressed in terms of the matrix operations in the table below.

.matrix operations
[[table_matrix_operations]]
|===
|Operation |Code |Definition

|stem:[0_{m}]
|`zeros(m)`
|stem:[m \times 1] column vector with elements equal to 0

|stem:[0_{mn}]
|`zeros(m, n)`
|stem:[m \times n] matrix with elements equal to 0

|stem:[1_{m}]
|`ones(m)`
|stem:[m \times 1] column vector with elements equal to 1

|stem:[1_{mn}]
|`ones(m, n)`
|stem:[m \times n] matrix with elements equal to 1

|stem:[\mathbb{I}_n]
|`identity(n)`
|stem:[n \times n] identity matrix

|stem:[X^\top]
|`X.transpose()`
|transposition

|stem:[cX]
|`c * X`
|scalar multiplication, stem:[c \in \mathbb{R}]

|stem:[X + Y]
|`X + Y`
|addition

|stem:[X - Y]
|`X - Y`
|subtraction

|stem:[X \cdot Z]
|`X * Z`
|matrix multiplication, also denoted as stem:[XZ]

|stem:[x^\top y~] or stem:[~x y^\top]
|`dot(x,y)`
|dot product, stem:[x,y \in \mathbb{R}^{m \times 1}] or stem:[x,y \in \mathbb{R}^{1 \times n}]

|stem:[X \odot Y]
|`hadamard(X,Y)`
|element-wise product of stem:[X] and stem:[Y]

|stem:[\mathsf{diag}(X)]
|`diag(X)`
|column vector that contains the diagonal of stem:[X]

|stem:[\mathsf{Diag}(x)]
|`Diag(x)`
|diagonal matrix with stem:[x] as diagonal, stem:[x \in \mathbb{R}^{1 \times n}]  or stem:[x \in \mathbb{R}^{m \times 1}]

|stem:[1_m^\top \cdot X \cdot 1_n]
|`elements_sum(X)`
|sum of the elements of stem:[X]

|stem:[x \cdot 1_n^\top]
|`column_repeat(x, n)`
|stem:[n] copies of column vector stem:[x \in \mathbb{R}^{m \times 1}]

|stem:[1_m \cdot x]
|`row_repeat(x, m)`
|stem:[m] copies of row vector stem:[x \in \mathbb{R}^{1 \times n}]

|stem:[1_m^\top \cdot X]
|`columns_sum(X)`
|stem:[1 \times n] row vector with sums of the columns of stem:[X]

|stem:[X \cdot 1_n]
|`rows_sum(X)`
|stem:[m \times 1] column vector with sums of the rows of stem:[X]

|stem:[\max(X)_{col}]
|`columns_max(X)`
|stem:[1 \times n] row vector with maximum values of the columns of stem:[X]

|stem:[\max(X)_{row}]
|`rows_max(X)`
|stem:[m \times 1] column vector with maximum values of the rows of stem:[X]

|stem:[(1_m^\top \cdot X) / n]
|`columns_mean(X)`
|stem:[1 \times n] row vector with mean values of the columns of stem:[X]

|stem:[(X \cdot 1_n) / m]
|`rows_mean(X)`
|stem:[m \times 1] column vector with mean values of the rows of stem:[X]

|stem:[f(X)]
|`apply(f, X)`
|element-wise application of stem:[f: \mathbb{R} \rightarrow \mathbb{R}] to stem:[X]

|stem:[e^X]
|`exp(X)`
|element-wise application of stem:[f: x \rightarrow e^x] to stem:[X]

|stem:[\log(X)]
|`log(X)`
|element-wise application of the natural logarithm stem:[f: x \rightarrow \ln(x)] to stem:[X]

|stem:[1 / X]
|`reciprocal(X)`
|element-wise application of stem:[f: x \rightarrow 1/x] to stem:[X]

|stem:[\sqrt{X}]
|`sqrt(X)`
|element-wise application of stem:[f: x \rightarrow \sqrt{x}] to stem:[X]

|stem:[X^{-1/2}]
|`inv_sqrt(X)`
|element-wise application of stem:[f: x \rightarrow x^{-1/2}] to stem:[X]

|stem:[\log(\sigma(X))]
|`log_sigmoid(X)`
|element-wise application of stem:[f: x \rightarrow \log(\sigma(x))] to stem:[X]
|===

Using this table leads to concise and uniform code. For example, the backpropagation implementation of a softmax layer looks like this:
[.small-code]
[source,cpp]
----
include::../include/nerva/neural_networks/layers.h[tag=matrix_operations]
----
See the specification document https://wiegerw.github.io/nerva-rowwise/pdf/nerva-library-specifications.pdf[Nerva library specifications] for an overview of how these matrix operations are used.

=== Eigen library
The {library} uses the https://eigen.tuxfamily.org/[Eigen library] for representing matrices. The matrix operations in table <<table_matrix_operations>> have been implemented using Eigen, see the file https://github.com/wiegerw/nerva-colwise/blob/main/include/nerva/neural_networks/matrix_operations.h[matrix_operations.h].

=== MKL library
Using the Eigen library alone is not sufficient for obtaining high performance. Therefore, the {library} uses the https://en.wikipedia.org/wiki/Math_Kernel_Library[Intel Math Kernel library (MKL)] as a backend. The Eigen library supports MKL by means of the compiler flag `EIGEN_USE_MKL_ALL`, see also https://eigen.tuxfamily.org/dox/TopicUsingIntelMKL.html[TopicUsingIntelMKL.html].
Note that the MKL library is included in the https://www.intel.com/content/www/us/en/developer/tools/oneapi/base-toolkit-download.html[Intel oneAPI base toolkit].

The MKL library supports a number of highly efficient, but extremely low-level interfaces for matrix operations. See https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-c/2024-2/blas-and-sparse-blas-routines.html[blas-and-sparse-blas-routines.html] for an overview. The {library} contains matrix classes that hide those low-level details from the user. The table below gives an overview of them.

|===
|Header file |Description

|`link:https://github.com/wiegerw/nerva-colwise/blob/main/include/nerva/neural_networks/mkl_dense_vector.h[mkl_dense_vector.h]`
|A class `dense_vector_view` that wraps a raw pointer to a vector.

|`link:https://github.com/wiegerw/nerva-colwise/blob/main/include/nerva/neural_networks/mkl_dense_matrix.h[mkl_dense_matrix.h]`
|A class `dense_matrix_view` that wraps a raw pointer to a matrix, and a class
`dense_matrix` that stores a dense matrix.

|`link:https://github.com/wiegerw/nerva-colwise/blob/main/include/nerva/neural_networks/mkl_sparse_matrix.h[mkl_sparse_matrix.h]`
|A class `sparse_matrix_csr` footnote:[Note that the name `sparse_matrix` could not be used due to a conflict with a #define of the same name buried deep inside the MKL library code] that stores a sparse matrix in
https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)[compressed sparse row] (CSR) format.
|===

TIP: In C++23 the implementation of sparse matrices in CSR format can be greatly simplified, as shown by https://github.com/BenBrock/matrix-cpos[Ben Brock].

NOTE: The sparse CSR matrix functions in the MKL library take an argument of the opaque type `sparse_matrix_t`. It stores unspecified properties of a sparse matrix. This parameter is poorly documented, and it is unknown when this parameter should be recalculated. For safety reasons, the {library} recalculates this parameter after every change to a sparse matrix, which may cause some inefficiencies. See also the function `sparse_matrix_csr::construct_csr` and
https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-c/2024-1/mkl-sparse-create-csr.html[mkl_sparse_?_create_csr].


// tag::io[]
[[io]]
== I/O
The default storage format used in the Nerva libraries is the NumPy NPZ format, see link:https://numpy.org/doc/stable/reference/generated/numpy.lib.format.html[numpy.lib.format]. The reason for choosing this format is portability between C++ and Python implementations. A file in `.npz` format can be used to store a dictionary of arrays.

The `{mlptool}` tool has options `--load-weights` and `--save-weights` for loading and saving the weights and bias vectors of an MLP, and options `--load-data` and `--save-data` for loading and saving a dataset in NPZ format. The keys in the dictionary for the weight matrices and bias vectors of linear layers are `W1, W2, ...` and `b1, b2, ...`. The keys for the training data plus targets are `Xtrain` and `Ttrain`, while for the test data plus targets we use `Xtest` and `Ttest`.
// end::io[]

== Performance
This section discusses various aspects that play a role for the performance of a neural network library.

=== Mini-batches
In textbooks and tutorials, the training of a neural network is usually explained in terms of individual examples. But in order to achieve high performance, it is absolutely necessary to use mini-batches. On https://en.wikipedia.org/wiki/Stochastic_gradient_descent#Iterative_method[Wikipedia] this is explained as follows:

____
A compromise between computing the true gradient and the gradient at a single sample is to compute the gradient against more than one training sample (called a "mini-batch") at each step. This can perform significantly better than "true" stochastic gradient descent described, because the code can make use of vectorization libraries rather than computing each step separately.
____

To support mini-batches, the {library} defines all equations that play a role in the execution of a neural network in matrix form, including the backpropagation equations, see the specification document https://wiegerw.github.io/nerva-rowwise/pdf/nerva-library-specifications.pdf[Nerva library specifications]. For the latter, many neural network frameworks rely on https://en.wikipedia.org/wiki/Automatic_differentiation[Automatic differentiation], see also cite:[DBLP_journals_jmlr_BaydinPRS17]. We use explicit backpropagation equations to implement truly sparse layers and to provide an instructive resource for those studying neural network execution.

=== Matrix products
The performance of training a neural network largely depends on the calculation of matrix products during the backpropagation step of linear layers. In order to do this efficiently, the https://en.wikipedia.org/wiki/Math_Kernel_Library[Intel Math Kernel library (MKL)] is used. Currently, this dependency is hard coded, but there are plans to make this optional. To experiment with other implementations, like SYCL or BLAS, a global setting is used that is discussed in the next section.

=== Nerva computation mode
In general, the performance of Eigen is very good. But occasionally, the generated code for a matrix expression can be quite poor. Especially in case of backpropagation calculations this can have a huge impact on the performance. The {library} uses a global setting `NervaComputation` to experiment with other implementations. For example, the function `softmax_layer::feedforward` contains this:
[.small-code]
[source,cpp]
----
include::../include/nerva/neural_networks/layers.h[tag=nerva_computation]
----
In this case, the default version `computation::eigen` turned out to have very poor performance. A direct call to an MKL routine is used to solve this problem. The `NervaComputation` setting is also used to experiment with BLAS implementations and SYCL implementations. See the file https://github.com/wiegerw/nerva-colwise/blob/main/include/nerva/neural_networks/optimizers.h[optimizers.h] for some examples of that.

TIP: The command line tool `mlp` has an option `--computation` to set the computation mode.

=== Subnormal numbers
Experiments with sparse neural networks have shown that the performance can be negatively influenced by https://en.wikipedia.org/wiki/Subnormal_number[subnormal numbers]. The example program `link:https://github.com/wiegerw/nerva-colwise/blob/main/examples/subnormal_numbers.cpp[subnormal_numbers.cpp]` illustrates the problem. The table below is the result of the following experiment.
The dot product of two large vectors of floating-point numbers is computed. One vector is filled with random values between 0 and 1, and the other with powers of 10, ranging from `1` to `1e−45`. For values larger than `1e−35`, the time needed for this calculation is about `0.044` seconds. For smaller values we end up in the range of subnormal numbers. This causes the runtime to increase more than eight-fold to `0.37` seconds. In our experiments we observed that when layers with high sparsity are used, it may happen that subnormal values appear in weight matrices, and their amount increases every epoch.
[.small-code]
[listing]
----
--- multiplication1 ---
time =   0.044372 | value = 1.0e+00    | sum = -5.49552e+03
time =   0.044567 | value = 1.0e-01    | sum = -5.49572e+02
time =   0.044243 | value = 1.0e-02    | sum = -5.49304e+01
time =   0.044434 | value = 1.0e-03    | sum = -5.49612e+00
time =   0.044253 | value = 1.0e-04    | sum = -5.49862e-01
time =   0.044765 | value = 1.0e-05    | sum = -5.49653e-02
time =   0.044698 | value = 1.0e-06    | sum = -5.49624e-03
time =   0.044683 | value = 1.0e-07    | sum = -5.49642e-04
time =   0.044703 | value = 1.0e-08    | sum = -5.49491e-05
time =   0.044821 | value = 1.0e-09    | sum = -5.49454e-06
time =   0.044705 | value = 1.0e-10    | sum = -5.49557e-07
time =   0.044657 | value = 1.0e-11    | sum = -5.49730e-08
time =   0.045235 | value = 1.0e-12    | sum = -5.49563e-09
time =   0.045120 | value = 1.0e-13    | sum = -5.49706e-10
time =   0.045010 | value = 1.0e-14    | sum = -5.49719e-11
time =   0.044988 | value = 1.0e-15    | sum = -5.49464e-12
time =   0.044943 | value = 1.0e-16    | sum = -5.49629e-13
time =   0.044795 | value = 1.0e-17    | sum = -5.49573e-14
time =   0.044147 | value = 1.0e-18    | sum = -5.49449e-15
time =   0.044166 | value = 1.0e-19    | sum = -5.49589e-16
time =   0.044380 | value = 1.0e-20    | sum = -5.49722e-17
time =   0.044036 | value = 1.0e-21    | sum = -5.49430e-18
time =   0.043405 | value = 1.0e-22    | sum = -5.49577e-19
time =   0.043615 | value = 1.0e-23    | sum = -5.49548e-20
time =   0.043544 | value = 1.0e-24    | sum = -5.49570e-21
time =   0.043547 | value = 1.0e-25    | sum = -5.49694e-22
time =   0.043536 | value = 1.0e-26    | sum = -5.49365e-23
time =   0.043560 | value = 1.0e-27    | sum = -5.49488e-24
time =   0.043500 | value = 1.0e-28    | sum = -5.49657e-25
time =   0.043524 | value = 1.0e-29    | sum = -5.49783e-26
time =   0.044128 | value = 1.0e-30    | sum = -5.49559e-27
time =   0.043585 | value = 1.0e-31    | sum = -5.49745e-28
time =   0.043530 | value = 1.0e-32    | sum = -5.49488e-29
time =   0.043609 | value = 1.0e-33    | sum = -5.49569e-30
time =   0.043805 | value = 1.0e-34    | sum = -5.49446e-31
time =   0.046169 | value = 1.0e-35    | sum = -5.49661e-32
time =   0.070594 | value = 1.0e-36    | sum = -5.49664e-33
time =   0.247938 | value = 1.0e-37    | sum = -5.49684e-34
time =   0.368848 | value = 1.0e-38    | sum = -5.49553e-35
time =   0.369819 | value = 1.0e-39    | sum = -5.49426e-36
time =   0.368434 | value = 1.0e-40    | sum = -5.49607e-37
time =   0.368747 | value = 1.0e-41    | sum = -5.49801e-38
time =   0.369033 | value = 1.0e-42    | sum = -5.50173e-39
time =   0.370241 | value = 9.9e-44    | sum = -5.47762e-40
time =   0.370065 | value = 9.8e-45    | sum = -4.97559e-41
time =   0.370310 | value = 1.4e-45    | sum = -1.44152e-41
----
On https://groups.google.com/g/llvm-dev/c/TDGKHFU4hzE/m/k-LEa3NvBQAJ[Google Groups] this problem is discussed. A possible solution is to instruct the compiler to flush subnormal values to zero. But there doesn't seem to be a portable way to achieve this. In the {library} different solutions have been tried. One of them is to periodically flush weights in the subnormal range to zero using the `--clip` command line option of the `mlp` tool.
In cite:[DBLP_journals_actanum_HighamM22] the problem of subnormal numbers is discussed.

== Sparse neural networks
Sparse neural network layers are often simulated using binary masks, see cite:[DBLP_journals_corr_abs-2102-01732]. This is caused by the lack of support for sparse tensors in popular neural network frameworks. Note that PyTorch is currently developing https://pytorch.org/docs/stable/sparse.html[sparse tensors]. The {library} supports truly sparse layers, meaning that the weight matrices of sparse layers are stored in a sparse matrix format. Another example of truly sparse layers is given by cite:[DBLP_conf_icml_NikdanPIKA23].

=== Sparse matrices
Since we are dealing with a programming context, we say that the _support_ of a sparse matrix refers to the set of positions (or indices) in the matrix that are explicitly stored. Elements inside the support can have a non-zero value. Elements outside the support have the value zero by definition.

Sparse matrices in the {library} are stored in
link:++https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)++[CSR] format.
This matrix representation stores arrays of column and row indices to define the support, plus an array of the corresponding values. CSR matrices are _unstructured_ sparse matrices, meaning they have non-zero elements located at arbitrary positions. Alternatively, there are _structured_ sparse matrices, take for example butterfly matrices cite:[DBLP_journals_corr_abs-2405-15013].

=== Sparse evolutionary training
Sparse evolutionary training (SET) is a method for efficiently training sparse neural networks, see e.g. cite:[DBLP_journals_nca_LiuMMPP21]. The idea behind this method is to start the training with a random sparse topology, and to periodically prune and regrow some of the weights.

=== Sparse initialization
In SET, the sparsity is not divided evenly over the sparse layers. Instead, small layers are assigned a higher density than larger ones.
 In cite:[DBLP_journals_nca_LiuMMPP21] formula (3), https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93R%C3%A9nyi_model[Erdős–Rényi graph topology]
 is suggested to calculate the densities of the sparse layers given a desired overall density of the sparse layers combined.
In the {library} this is implemented in the function `compute_sparse_layer_densities`, see `link:https://github.com/wiegerw/nerva-colwise/blob/main/include/nerva/neural_networks/layer_algorithms.h[layer_algorithms.h]`. The original Python implementation can be found
https://github.com/VITA-Group/Random_Pruning/blob/871077f1d10f9bc44941b093fd5ccbc4ec3984fa/CIFAR/sparselearning/core.py#L155[here], along with several other sparse initialization strategies.
In the tool `mlp` the option `--overall-density` is used for assigning Erdős–Rényi densities to the sparse layers. See <<mlp_output>> for an example of this. The overall density of `0.05` is converted into densities `[0.042382877, 0.06357384, 1.0]` for the individual layers.

=== Pruning weights
Pruning weights is about removing parameters from a neural network, see also https://en.wikipedia.org/wiki/Pruning_(artificial_neural_network)[Pruning (artificial_neural_network)]. In our context removing parameters is about removing elements from the support of a sparse weight matrix. The effect of this is that the values corresponding to these elements are zeroed.

==== Threshold pruning
In threshold pruning, all weights stem:[w_{ij}] with stem:[|w_{ij}| \leq t] for a given threshold stem:[t] are pruned from a weight matrix stem:[W].

==== Magnitude based pruning
Magnitude based pruning is special case of threshold pruning. In magnitude based pruning, the threshold stem:[t] is computed such that for a given fraction stem:[\zeta] of the weights we have stem:[|w_{ij}| \leq t]. To ensure that the desired fraction of weights is removed, our implementation takes into account that there can be multiple weights with
stem:[|w_{ij}| = t].

==== SET based pruning
In SET based pruning, magnitude pruning is applied to positive weights and negative weights separately. So a fraction stem:[\zeta] of the positive weights and a fraction stem:[\zeta] of the negative weights are pruned.

=== Growing weights
Growing weights is about adding parameters to a neural network. In our context adding parameters is about adding elements to the support of a sparse weight matrix.

==== Random growing
In random growing, a given number of elements is chosen randomly from the positions outside the support of a weight matrix. These new elements are then added to the support. Since the new elements need to be initialized, a weight initializer needs to be chosen to generate values for them.

A specific implementation `grow_random` for matrices in CSR format has been developed, that uses https://en.wikipedia.org/wiki/Reservoir_sampling[reservoir sampling] to determine the new elements that are added to the support.

=== Classes for pruning and growing
In the {library}, the classes `prune_function` and `grow_function` are used to represent generic pruning and growing strategies:
[.small-code]
[source,cpp]
----
include::../include/nerva/neural_networks/prune.h[tag=doc]
----

[.small-code]
[source,cpp]
----
include::../include/nerva/neural_networks/grow.h[tag=doc]
----

In the command line tool `mlp` the user can select specific implementations of these prune and grow functions. They are called at the start of each epoch of training via an attribute `regrow_function` that applies pruning and growing to the sparse layers of an MLP. See also the <<on_start_epoch>> event.

=== Experiments with sparse training
In cite:[wesselink2024nervatrulysparseimplementation] we report on some of our experiments with sparse neural networks.

An example of a dynamic sparse training experiment is
[.small-code]
[source,bash]
----
include::../examples/cifar10_pruning.sh[tag=doc]
----
At the start of every epoch 20% of the weights is pruned, and the same number of weights is added back at different locations.
The output may look like this:
[.small-code]
[listing]
----
=== Nerva c++ model ===
Sparse(input_size=3072, output_size=1024, density=0.042382877, optimizer=Nesterov(0.90000), activation=ReLU())
Sparse(input_size=1024, output_size=1024, density=0.06357384, optimizer=Nesterov(0.90000), activation=ReLU())
Dense(input_size=1024, output_size=10, optimizer=Nesterov(0.90000), activation=NoActivation())
loss = SoftmaxCrossEntropyLoss()
scheduler = ConstantScheduler(lr=0.01)
layer densities: 133325/3145728 (4.238%), 66662/1048576 (6.357%), 10240/10240 (100%)

epoch   0 lr: 0.01000000  loss: 2.30284437  train accuracy: 0.07904000  test accuracy: 0.08060000 time: 0.00000000s
epoch   1 lr: 0.01000000  loss: 2.14723837  train accuracy: 0.21136000  test accuracy: 0.21320000 time: 5.48583113s
pruning + growing 26665/133325 weights
pruning + growing 13332/66662 weights
epoch   2 lr: 0.01000000  loss: 1.91203228  train accuracy: 0.30918000  test accuracy: 0.30900000 time: 5.00460376s
pruning + growing 26665/133325 weights
pruning + growing 13332/66662 weights
----

[[extending]]
== Extending the library
The {library} can be extended in several obvious ways, such as adding new layers, activation functions, loss functions, learning rate schedulers and pruning or growing functions. This can be done by inheriting from the appropriate base class and implementing the required virtual functions. The table below provides an overview:

|===
|Functionality |Base class

|A layer
|`neural_network_layer`

|An activation function
|`activation_function`

|A loss function
|`loss_function`

|A learning rate scheduler
|`learning_rate_scheduler`

|A pruning function
|`prune_function`

|A growing function
|`grow_function`
|===

It is recommended to follow the approach advocated in the Nerva libraries. Each implementation should be based on a mathematical specification, as shown in the
https://wiegerw.github.io/nerva-rowwise/pdf/nerva-library-specifications.pdf[Nerva library specifications] document.
After defining the mathematical equations, you can use the table of <<table_matrix_operations>> to convert the equations into code.

Another crucial step is validation and testing. The symbolic mathematics library
https://docs.sympy.org/latest/index.html[SymPy]
can be used to validate the equations.
The https://github.com/wiegerw/nerva-sympy[nerva-sympy] repository contains https://github.com/wiegerw/nerva-sympy/tree/main/tests[test cases] for activation functions, loss functions, layers, and even for the derivation of equations.

== References

bibliography::[]
